#!/bin/bash

####################################################################################
# Note to future generations/programmers:
#
# The qtility script was designed for use on a number of the Census Bureau's 
# research computers. It implements easy access points for users to run standard
# processing tools within the PBS Pro queueing system. Primarily this is meant
# for the majority of users who want to "just run my SAS program" or whatever.
# This is not going to be all that useful for a small set of expert PBS Pro users
# who need very specific tweaks for their programs to run. Some of the most basic
# and useful PBS options will be implemented here. And others can be added in the
# future as needed.
#
# A few requirements:
# - Calling qtility will be done with links. So, for example, we'll have:
#   qstata -> qtility, or
#   qR -> qtility, and the main qtility script will figure how it was called and how
#   it should work based on that.
# - For the most basic operations, the q script should be fully subtitutable for the
#   the original program call (i.e. "sas myprogram.sas" can be replace with
#   "qsas myprogram.sas"). Kind of a "simple mode".
# - Some PBS- and program-specific options can be accessed with double-dash command
#   line options in a sort of "advanced mode".
# - Changes to the core qtility script should not - in general - change the way 
#   currently implemented scripts work.
#
#
# The overall architecture of the script is as follows:
# 1. Parse the script name so we know how to handle program-specific stuff.
# 2. Parse the general arguments.
# 2a. Parse the program-specific arguments.
# 3. Check the general arguments for consistency and complete them if necessary.
# 3b. Check the program-specific arguments.
# 4. If requested, print all the checked/completed parameters.
# 5. If not in debug mode, submit the program-specific job.
#
#
# To Do:
# 1. Finish implementing err flag. In general err should be set to true when there
#    is a problem. This should trigger a somewhat graceful exit at a later point.
# 2. Implement qstata
# 3. Implement qR
# 4. Implement qgauss
# 5. Implement qmatlab
#
# NOTE: To prevent confusion with currently implemented scripts, this program expects
# to be called with scripts that have a "2" suffixed on to the standard script names.
# So for example, since qsas is being actively used, this script should be called
# with qsas2. When this script is ready to go to production, this can be fixed by
# altering the parse_script_call function.
####################################################################################
# Initializations.

# Check out how the script was called.
script=$(basename $0)

# Get argument information.
args=$@
argcnt=$#

# Set the initial error condition.
err=false

# Temporary variables for debugging.
verbose=yes
####################################################################################
function print_help
{
	${OPT}_help head
    cat << EOF
By default the number of chunks/cpucount is 1.

Options:
EOF
	${OPT}_help opts
	cat << EOF
    --chunks=NUM,
    --cpucount=NUM        Use NUM chunks/CPUs to process the SAS program.
    --memsize=NUM         Set the SAS memsize as NUM megabytes.
    --pbsname=LABEL       Set the name of the job for entering in the PBS queue. The standard is to
                          use the first 15 digits of the program name.
    --mailops=OPS         Set the PBSPro events for which emails should be sent. The --mailto option must be set
                          properly for any email notifications to go out. The options are as follow:
                          n=No Emails (default); a=Send mail if job is aborted; b=Send mail when job executes; and
                          e=Send mail when job terminates. a, b, and e, can be used in combination.
    --mailto=ADDR         Send PBSPro event emails to ADDR, which should be in the form of USER@SERVER. Use
                          the --mailops option to set which event emails should be sent.
    --verbose             Turn on verbose mode. Prints all settings prior to running job.
    --debug               Turn on debug. All code will run except that the job will not be placed in the PBS
                          queue. Also, running in debug mode will set the verbose flag as well.

Based on code by Rob Creecy
General qtility code written by Matthew Graham
EOF
	${OPT}_help tail
	exit 0
}
####################################################################################

####################################################################################
# This function determines how the script what called. Later this will help us 
# understand how to parse the rest of the command string.
#
# Any option that appears here must have a complete function handler, which consists
# of the following:
# - OPT_help
# - OPT_parse_args
# - OPT_check_args
# - OPT_verbose_print
# - OPT_submit
#
function parse_script_call
{
	thisprog=$(basename $0)

	case $thisprog in
        qsas2)
			OPT=qsas
			echo "Called with qsas2!"
			;;
        qstata2)
			OPT=qstata
			echo "Called with qstata2!"
            ;;
        qR2)
			OPT=qR
            echo "Called with qR2!"
            ;;
        qgauss2)
			OPT=qgauss
            echo "Called with qgauss2!"
            ;;
        qmatlab2)
			OPT=qmatlab
            echo "Called with qmatlab2!"
            ;;
        qtility)
			OPT=
            echo "Called with qtility :("
            ;;
        *)
			OPT=
            echo "WHOA! No idea how we got here..."
            ;;
	esac
}
####################################################################################

####################################################################################
# This function pulls out the general arguments that are needed by PBS Pro and which
# should be standard across all the different options. All other arguments should be
# passed to the option specific parser.
#
# The general arguments that need to be parsed are:
# - pbsname
# - mailto
# - mailops
# - resources (memsize cpucount)
# - memsize
# - cpucount
# - verbose
# - debug
# - quiet
#
function parse_args
{
	set -- $args
	[[ $# = 0 ]] && print_help
	case $1 in
		--help|-h)
			print_help
			;;
		-*)
			positional=no
			;;
		*)
			positional=yes
			${OPT}_parse_args positional
			;;
	esac
	[[ $positional = yes ]] && return

	remaining_args=
	while [[ ! -z $1 ]]
	do
		case $1 in
			--chunks*)
				cpucount=${1##*=}
				;;
			--cpucount*)
				cpucount=${1##*=}
				;;
			--memsize*)
				rawmemsize=${1##*=}
				if [[ $rawmemsize -lt 20 ]]
				then
				    echo "Warning: memsize not allowed to be less than 20 (MB). Resetting to 20MB."
				    rawmemsize=20
				fi
				if [[ $rawmemsize -gt 80000 ]]
				then
				    echo "Warning: memsize not allowed to be greater than 80 GB. Resetting to 80000MB."
				    rawmemsize=80000
				fi
				;;
			--pbsname*)
				pbsname=${1##*=}
				;;
			--mailops*)
				mailops=${1##*=}
				;;
			--mailto*)
				mailto=${1##*=}
				;;
		    --verbose*)
			    verbose=yes
				;;
		    --debug*)
		        echo "Debug Mode On: PBS Job will NOT be started."
		        debug=yes
 		        verbose=yes
				;;
			--quiet*)
				quiet=yes
				;;
			--*)
				# Found option-specific positional parameter. Passing it on.
				remaining_args="$remaining_args $1"
				;;
			*)
				echo "Oops. Bad parameter structure. Optional parameters require a leading '--'. Check your command line"
				echo "Your poorly structured parameter was: $1"
				err=true
				;;
		esac
		shift
	done
	[[ -z $sasprog && -z $cpucount ]] && print_help
	${OPT}_parse_args optional $remaining_args

}
####################################################################################

####################################################################################
function check_args
{
	# Checking general arguments
	[[ -z $cpucount ]] && cpucount=1
	[[ -z $rawmemsize ]] && rawmemsize=$(( ${cpucount}*5000 ))
    [[ -z $pbsname ]] && pbsname=${baseprog:0:15}
    [[ -z $mailto ]] && mailto=$USER
    [[ -z $mailops ]] && mailops=n
	resources="-l ncpus=$cpucount,mem=${memsize}mb"

	# Cpucount needs to be less than 16.
    if [[ cpucount -gt 16 ]]
    then
		echo "The number of CPUs (chunks) cannot be larger than 16."
		echo "You entered: chunks/cpucount=$cpucount"
		exit 2
    fi

	# These variables need special formatting after getting their values.
    memsize=$rawmemsize"m"

	# Call program-specific argument parser.
	${OPT}_check_args
}
####################################################################################

####################################################################################
function qsas_help
{
	case $1 in
		head)
			cat << EOF
Usage: qsas prog[.sas] [CHUNKS/CPUCOUNT]
       qsas --sasprog=prog[.sas] [OPTION]... 
Launch SAS under PBS-like systems and allow adjustment of SAS command-line parameters.
Setting the sasprog is mandatory, all other parameters are optional.
Currently sets memsize, sortsize, and sumsize automatically. When specifying the number
of chunks/cpucount, these variables will be set as follows unless overridden in the options:
    memsize = chunks * 5000MB
    sortsize = memsize - 10MB
    sumsize = memsize - 10MB
EOF
			;;	
		opts)
			cat << EOF
    --sasprog=FILE        Run FILE in a PBS-like system. '.sas' extension need not be specified.
    --sortsize=NUM        Set the SAS sortsize as NUM megabytes. sortsize may not be larger than memsize.
    --sumsize=NUM         Set the SAS sumzie as NUM megabytes. sumsize may not be larger than memsize.
    --altlog=FILE         Set the SAS altlog to be FILE. No error checking is done on the file or location.
EOF
			;;	
		tail)
			cat << EOF
SAS-specific handler written by Matthew Graham
Report bugs to <matthew.graham@census.gov>.
EOF
			;;	
	esac	
}
####################################################################################

####################################################################################
function qsas_parse_args
{
	case $1 in
		positional)
			set -- $args
			[[ -z $1 ]] || sasprog=$1
			[[ -z $2 ]] || cpucount=$2
			if [[ $# -gt 2 ]]
			then
			    echo "Warning: Too many positional parameters."
			    print_help
			fi
			quiet=no
			;;
		optional)
			shift
			while [[ ! -z $1 ]]
			do
				case $1 in
					#vvvvvvvvvvv MODIFY SAS OPTIONS BELOW HERE vvvvvvvvvvv
					--sasprog*)
						sasprog=${1##*=}
						;;
					--sortsize*)
						sortsize=${1##*=}
						if [[ $sortsize -ge $rawmemsize ]]
						then
							echo "Warning: sortsize (${sortsize}) must be less than memsize (${rawmemsize})."
							echo "Resetting sortsize to be 10MB less than memsize."
							sortsize=
						fi
						;;
					--sumsize*)
						sumsize=${1##*=}
						if [[ $sumsize -ge $rawmemsize ]]
						then
							echo "Warning: sumsize (${sumsize}) must be less than memsize (${rawmemsize})."
							echo "Resetting sumsize to be 10MB less than memsize."
							sumsize=
						fi
						;;
					--altlog*)
						altlog=${1##*=}
	    				# check for fullpath here
						if [[ "$(dirname $altlog)" = "." ]]
						then
							altlog=$(pwd)/$(basename $altlog)
						fi
						;;
					#^^^^^^^^^^ MODIFY SAS OPTIONS ABOVE HERE ^^^^^^^^^^
					*)
						echo "Oops. Your parameter was unknown by the general parser and by the SAS parser. Check your command line"
						echo "Your bad parameter was: $*"
						err=true
						;;
				esac
				shift
			done

			;;
	esac


}
####################################################################################

####################################################################################
function qsas_check_args
{
	# Reform the program name to make sure the ".sas" extension is there.
	baseprog=$(basename $sasprog .sas)
	sasprog=$(dirname $sasprog)/$baseprog.sas

   	# If current directory is referenced, change to full path.
	# All other relative directory references will be left intact.
	if [[ "$(dirname $sasprog)" = "." ]]
	then
		sasprog=$(pwd)/$(basename $sasprog)
	fi

	[[ -z $sumsize ]] && sumsize=$(( ${rawmemsize}-10 ))
	[[ -z $sortsize ]] && sortsize=$(( ${rawmemsize}-10 ))
	[[ -z $altlog ]] || extras="-altlog ${altlog}"

	# These variables need special formatting after getting their values.
    sumsize=$sumsize"m"
    sortsize=$sortsize"m"
}
####################################################################################

####################################################################################
function qsas_verbose_print
{
    cat <<EOF
Verbose Mode On

PARAMETERS:
sasprog=$sasprog 
chunks/cpucount=$cpucount 
memsize=$memsize 
sumsize=$sumsize 
sortsize=$sortsize 
extras=$extras 
pbsname=$pbsname 
mailto=$mailto
mailops=$mailops
resources=$resources
sas command=sas -noterminal -cpucount $cpucount -memsize $memsize -sumsize $sumsize -sortsize $sortsize $extras $sasprog

EOF
}
####################################################################################

####################################################################################
function qsas_submit
{
    echo '#!/bin/bash' "
#PBS -N $pbsname
#PBS -M $mailto
#PBS -m $mailops
#PBS $resources
#PBS -j oe
cd $PWD
sas -noterminal -cpucount $cpucount -memsize $memsize -sumsize $sumsize -sortsize $sortsize $extras $sasprog" | qsub
}
####################################################################################


####################################################################################
#------ Run Main Program ------
parse_script_call
parse_args
check_args
[[ -z $verbose ]] || ${OPT}_verbose_print
#[[ -z $debug ]] && ${OPT}_submit

